# What's this?
An OpenGL based remake of the classic game released originally for various 8-bit computers (like Commodore and Amiga). Based on my favourite childhood game, played on a Commodore 16, the product of the now defunct  software studio Gremlin Graphics  dating back to 1986.

### Raison d'être
I am working as a SW developer for more than 10 years (mostly working on computer vision and embedded projects) and this time I wanted to create something very different, which is more complex than just drawing some 3D elements on the screen. My original intention was to [learn OpenGL](https://learnopengl.com/) in a pragmatic way to gain skills I can use in my professional career. 

Eventually, as I have faced more and more challenges of such a complex thing as a game development it evolved to something between a multimedia project (eg. the game features my self-composed music) and an open source development (contains reusable components, which can be reused in other, even non-game projects as well).

![enter image description here](https://raw.githubusercontent.com/abprogramming/TrailBlazeR/c2e5161fb7e33e2ed5aaf81179e3b422979430cf/doc/screenshot.png)

## Features
* Lead to ball on the race tracks floating above planets of the solar system to the finish line thru 10 exciting levels
* Inspiring background artworks generated by AI [(NightCafé)](https://creator.nightcafe.studio/studio)
* Self composed theme music originally composed with  [my experimental/ambient project](https://thetruemorkskog.bandcamp.com/music)
* The sound effects are also self-recorded using analogue synthesizers

# Quick start
If you just want to try the game maybe the easiest way is to download the Windows x64 builds I have provided on the Releases page. The game was originally developed on Ubuntu 20, but I have prepared Windows binaries for download as well for testing purposes.

## Building from source
If you want to build the game from sources you'll need the following libraries/dependencies:
* GLFW3
* GLM
* LibPNG
* SFML (audio and system components)

The supplied CMake project file can be used to build the project. I have tested with GCC 9.4.0, but probably any compiler will do which supports at least the C++20 standard.

# Reusable parts of the project
The project's source code contains some parts which can be useful maybe even for your projects, which is offered for free reuse under the Unlicense.

## GLKit
The heart and soul of the game graphics is a self-developed wrapper around OpenGL, which uses modern C++ design principles for type and memory safe, convenient use of OpenGL. All classes, which wraps some OpenGL features are. Also the subcomponents are as decoupled as it was possible, so they can be used even without each other if you are just looking for some of the following (see `include/glkit/core` for details):
* `buffers`, for safe usage of VAO's, VBO's and EBO's, designed using the RAII principles. 
* `shaders`, for compiling and wrapping shader programs, satisfying the requirements of modern OpenGL development using the core profile (supports geomerty and tesselation shaders in addition to the mandatory vertex and fragment shader)
* `uniforms`, for type safe and versatile handling and updating shader uniform variables using modern C++'s compile time features and lambdas

Please note, that the GLKit core component uses OpenGL bindings provided by GLAD, which is committed into this repo, as it is generated using a [web service].(https://glad.dav1d.de/)

## State machine

The project features a single-header state machine API, also relying on modern C++'s functional features. It is a fairly new addition to the game's codebase, but it was needed to clean up the game's main state handling (realized in `GameControl_c`), which was a huge mess by the finishing end of the planned functionalist with lots of `if`'s - and also designed with the negative experiences I had in my professional career of poorly designed state machines, which always led to obfuscated and hard-to-maintain code.

This state machine API relies on a type representing a state transition, which defines an initial and a target state. All these transition objects are collected in a `StateMachine_c` object, which facilitates the transition, which is only possible thru it's public API (`performTransition()`) By collecting all the transitions it is ensured, that no unwanted or illegal state change will take place. The transition happens and `State` changes if a predicate defined in the state transition object tests as true. In addition, there are two special functors which can be associated with a transition, where the API user can implement extra functionality which will be executed before or on the state change. Thanks to this, the original `GameControl_c` code, which featured `if`'s up to three levels depth was replaced by 11 calls of `addTransition()'
